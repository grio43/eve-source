#Embedded file name: C:\BuildAgent\work\ba3dced9a47cf95a\eve\release\V22.02\packages\behaviors\registry\decorators.py
from behaviors.registry.registrator import register_decorator
from fsd import attributes
register_decorator('behaviors.decorators.modifiers.ForceFailure')
register_decorator('behaviors.decorators.modifiers.ForceSuccess')
register_decorator('behaviors.decorators.modifiers.Not')
register_decorator('behaviors.decorators.modifiers.Uninterruptible')
register_decorator('behaviors.decorators.modifiers.Invulnerable', dict(reason=attributes.StringAttribute()))
register_decorator('behaviors.decorators.repeaters.RepeatWhileFailing', dict(maxRepetitions=attributes.IntegerAttribute()))
register_decorator('behaviors.decorators.timers.CooldownTimer', dict(timerAddress=attributes.BlackboardAddressAttribute(), timeoutSeconds=attributes.IntegerAttribute()), short_description='Prevents access to sub-behavior again util after a cooldown time has passed.', detailed_description="If the timer is in active the task will evaluate the child task and activate the timer, timing out after [timeoutSeconds]. The task will return what ever state the child task returns. If the timer is active the task will fail and not evaluate the child task. The timer can be reset by setting the [timerAddress] to None, the original timer will still reset the tree when it times out.  The cool-down can also be blocked if [timerAddress] is set to a 'bad' value while the timer is inactive, otherwise the original timer will reset the cool-down again.")
register_decorator('behaviors.decorators.timers.RandomCooldownTimer', dict(timerAddress=attributes.BlackboardAddressAttribute(index=0), minTimeoutSeconds=attributes.IntegerAttribute(index=1), maxTimeoutSeconds=attributes.IntegerAttribute(index=2)), short_description='Prevents access to sub-behavior again util after a randomized cooldown time has passed.', detailed_description="If the timer is in active the task will evaluate the child task and activate the timer, timing out after a random time between [minTimeoutSeconds] and [maxTimeoutSeconds]. The task will return what ever state the child task returns. If the timer is active the task will fail and not evaluate the child task. The timer can be reset by setting the [timerAddress] to None, the original timer will still reset the tree when it times out.  The cool-down can also be blocked if [timerAddress] is set to a 'bad' value while the timer is inactive, otherwise the original timer will reset the cool-down again.")
register_decorator('behaviors.decorators.modifiers.Cloaked')
register_decorator('behaviors.decorators.modifiers.OneShot', dict(oneShotTriggeredFlagAddress=attributes.BlackboardAddressAttribute()), short_description='Makes sure the decorated sub-tree is only run once.', detailed_description='Make a sub-behavior single shot by marking that it has already executed on the blackboard. This is very useful to for initialization that should only take place once for the lifetime of the entity.')
