#Embedded file name: C:\BuildAgent\work\ba3dced9a47cf95a\eve\release\V22.02\packages\behaviors\registry\actions.py
import inventorycommon.const as inv_const
from behaviors.registry.registrator import register_action
from fsd import attributes
register_action('behaviors.actions.WaitAction', dict())
register_action('behaviors.actions.ToggleAction', dict(trueOrFalse=attributes.BooleanAttribute(default=True)))
register_action('behaviors.actions.awareness.AddMyItemIdToSpawnPoolFleetAwareness', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0)))
register_action('behaviors.actions.awareness.ComputeCentroidAndRadiusOfItemIds', dict(itemIdsAddress=attributes.BlackboardAddressAttribute(index=0), centroidPositionAddress=attributes.BlackboardAddressAttribute(index=1), radiusPositionAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.awareness.SendCentroidOfBallIds', dict(ballIdListAddress=attributes.BlackboardAddressAttribute(), centroidPositionAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.awareness.InitializeEnemyClusterGeneration', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0), updateIntervalSeconds=attributes.IntegerAttribute(default=20, index=1), enemyClustersAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.awareness.InitializeGroupAwareness', dict(threatRange=attributes.IntegerAttribute(default=150000, index=0), maxSensorDrift=attributes.IntegerAttribute(default=20000, index=1), threatTimeoutSeconds=attributes.IntegerAttribute(default=900, index=2), updateTimeSeconds=attributes.IntegerAttribute(default=10, index=3), combatTargetsSetAddress=attributes.BlackboardAddressAttribute(index=4), includedCategories=attributes.InventoryCategorySetAttribute(index=5), excludedGroups=attributes.InventoryGroupSetAttribute(index=6), trackedTypeListID=attributes.EveTypeListSelectAttribute(index=7, is_optional=True), standingsEnabled=attributes.BooleanAttribute(index=8, default=True), reactToDisapproval=attributes.BooleanAttribute(index=9, default=False, is_optional=True), fwAttackMethod=attributes.FwAttackMethodAttribute(index=10, is_optional=True)), short_description='Initializes entity group awareness. Call once with a OneShot on the group level.', detailed_description='Registers an entity group awareness. Fails if attempting to owerwrite previously registered awarenesses.')
register_action('behaviors.actions.awareness.InitializeSpawnPoolFleetAwareness', dict(threatRange=attributes.IntegerAttribute(default=400000, index=0), maxSensorDrift=attributes.IntegerAttribute(default=50000, index=1), threatTimeoutSeconds=attributes.IntegerAttribute(default=900, index=2), updateTimeSeconds=attributes.IntegerAttribute(default=30, index=3), combatTargetsSetAddress=attributes.BlackboardAddressAttribute(index=4), includedCategories=attributes.InventoryCategorySetAttribute(index=5), excludedGroups=attributes.InventoryGroupSetAttribute(index=6), spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=7)))
register_action('behaviors.actions.awareness.SelectClusterWeightedByThreat', dict(enemyClustersAddress=attributes.BlackboardAddressAttribute(index=0), clusterCentroidAddress=attributes.BlackboardAddressAttribute(index=1), clusterRadiusAddress=attributes.BlackboardAddressAttribute(index=2), clusterItemIdsAddress=attributes.BlackboardAddressAttribute(index=3), guardObjectIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=4)))
register_action('behaviors.actions.ballparks.WarpToItem', dict(warpToItemIdAddress=attributes.BlackboardAddressAttribute(index=1), warpAtDistanceAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=2), jitterRadius=attributes.IntegerAttribute(index=3, is_optional=True), warpScrambledAddress=attributes.BlackboardAddressAttribute(index=4)))
register_action('behaviors.actions.ballparks.WarpToNewLocation', dict(locationMessage=attributes.BlackboardAddressAttribute(index=1), warpScrambledAddress=attributes.BlackboardAddressAttribute(index=2), warpAtDistanceAddress=attributes.BlackboardAddressAttribute(index=3, is_optional=True), jitterRadius=attributes.IntegerAttribute(index=4, is_optional=True)))
register_action('behaviors.actions.ballparks.SelectCoordinateNearLocationAction', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), locationAddress=attributes.BlackboardAddressAttribute(), minDistance=attributes.FloatAttribute(), maxDistance=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.SelectCoordinateNearCoordinateAction', dict(sourceCoordinateAddress=attributes.BlackboardAddressAttribute(), destinationCoordinateAddress=attributes.BlackboardAddressAttribute(), minDistance=attributes.FloatAttribute(), maxDistance=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.SelectCoordinateNearBall', dict(targetBallAddress=attributes.BlackboardAddressAttribute(index=0), destinationCoordinateAddress=attributes.BlackboardAddressAttribute(index=1), minDistance=attributes.FloatAttribute(index=2), maxDistance=attributes.FloatAttribute(index=3)))
register_action('behaviors.actions.ballparks.ApproachCoordinatesAction', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), notifyRange=attributes.FloatAttribute(), blocking=attributes.BooleanAttribute()))
register_action('behaviors.actions.ballparks.ApproachObject', dict(itemIdAddress=attributes.BlackboardAddressAttribute(), notifyRange=attributes.FloatAttribute(default=0.0), approachRange=attributes.FloatAttribute(default=0.0), blocking=attributes.BooleanAttribute(), approachRangeAddress=attributes.BlackboardAddressAttribute(is_optional=True)), short_description='Approach an object by ID from a blackboard', detailed_description='Direct NPC to approach a particular target as specified by itemIdAddress. The approachRange is in meters and can be provided from the blackboard by using approachRangeAddress instead which will override it.  You can make the task blocking by setting the blocking boolean if you do the notifyRange will be distance at which the behavior will stop blocking it should always be bigger than the approach range or else riskbeing permanently blocked.')
register_action('behaviors.actions.ballparks.OrbitAtDistanceAction', dict(orbitTargetAddress=attributes.BlackboardAddressAttribute(is_optional=True), orbitRange=attributes.FloatAttribute(is_optional=True), blocking=attributes.BooleanAttribute(), blockUntilRange=attributes.FloatAttribute(is_optional=True), blockUntilRangeAddress=attributes.BlackboardAddressAttribute(is_optional=True), orbitRangeAddress=attributes.BlackboardAddressAttribute(is_optional=True), velocityFraction=attributes.FloatAttribute(is_optional=True)))
register_action('behaviors.actions.ballparks.FullStopAction')
register_action('behaviors.actions.ballparks.SelectTargetToAnalyzeAction', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute(), maxDistance=attributes.FloatAttribute(), ignoredCategories=attributes.InventoryCategorySetAttribute(), ignoredGroups=attributes.InventoryGroupSetAttribute(), ignoredTypes=attributes.InventoryTypeSetAttribute(), shouldIgnoreMobileTargets=attributes.BooleanAttribute()))
register_action('behaviors.actions.ballparks.GetBallWarpToLocation', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), locationAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.GetItemIdByTypeId', dict(typeIds=attributes.InventoryTypeSetAttribute(index=0), itemIdAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Get the first itemID in bubble that matches typeIds', detailed_description='Get the ID of the first object of type from a type id list. Needs to used by an item behavior.')
register_action('behaviors.actions.ballparks.GetItemIdByTypeIdsFromBlackboard', dict(typeIdsAddress=attributes.BlackboardAddressAttribute(index=0), itemIdAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Get the ID of the first object in bubble that matches type ids from blackboard', detailed_description='Get the ID of the first object in bubble that matches type ids from blackboard. Needs to used by an item behavior.')
register_action('behaviors.actions.ballparks.GetRandomDeepSpacePosition', dict(locationAddress=attributes.BlackboardAddressAttribute()), short_description='Generate a random Deep Space Coordinate.', detailed_description='Generate a random deep space coordinate away from any planet. Location will 5 AU to furthest planet + 16 AU  away from the sun.')
register_action('behaviors.actions.ballparks.GetRandomPositionNearRandomPlanet', dict(locationAddress=attributes.BlackboardAddressAttribute(), minDistanceAU=attributes.FloatAttribute(), maxDistanceAU=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.GotoPosition', dict(coordinateAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.TransferToLocation', dict(locationAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.TransferItemToLocation', dict(itemIdAddress=attributes.BlackboardAddressAttribute(index=0), locationAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.ballparks.GetObjectSpaceLocation', dict(itemIdAddress=attributes.BlackboardAddressAttribute(), locationAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.MakeSelfInvulnerable', dict(reason=attributes.StringAttribute()))
register_action('behaviors.actions.ballparks.CancelInvulnerabilityForSelf', dict(reason=attributes.StringAttribute()))
register_action('behaviors.actions.ballparks.Cloak')
register_action('behaviors.actions.ballparks.Uncloak')
register_action('behaviors.actions.ballparks.SelectItemByTypes', dict(typeIds=attributes.InventoryTypeSetAttribute(index=0), selectedItemAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Select the first item ID in bubble matching requested type IDs.', detailed_description='Select the first item ID in the current bubble that matches the types in [typeIDs]. Will succeed it item is found and post the item ID to [selectedItemAddress] in the blackboard.  If no item is found the task fails.')
register_action('behaviors.actions.ballparks.SelectItemByGroups', dict(groupIds=attributes.InventoryGroupSetAttribute(index=0), selectedItemAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Select the first object in bubble matching requested group IDs.', detailed_description='Select the first object in the current bubble that matches the groups in [groupIds]. Will succeed if an object is found and post the item ID to [selectedItemAddress] in the blackboard. If no item is found the task fails.')
register_action('behaviors.actions.ballparks.StoreSunToBlackboardValue', dict(targetAddress=attributes.BlackboardAddressAttribute(index=0)), short_description='Store the ID of the sun on a blackboard.', detailed_description='Select the ID of the sun and saves it to the specified blackboard. If no sun is found the task fails.')
register_action('behaviors.actions.ballparks.SelectClosestPointOnObject', dict(objectIdAddress=attributes.BlackboardAddressAttribute(), closestPointAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.GetBallsInBubbleByOwnerIds', dict(ownerListAddress=attributes.BlackboardAddressAttribute(), objectListAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.EntityLootItem', dict(itemIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.StoreSlimItemFieldInItemSettingsAction', dict(slimItemFieldName=attributes.BlackboardAddressAttribute(index=0), slimItemFieldValue=attributes.BlackboardAddressAttribute(index=1), targetAddress=attributes.BlackboardAddressAttribute(index=2, is_optional=True)))
register_action('behaviors.actions.ballparks.StoreBlackboardToSlimItemAttribute', dict(targetAddress=attributes.BlackboardAddressAttribute(), messageAddress=attributes.BlackboardAddressAttribute(), attributeName=attributes.StringAttribute()))
register_action('behaviors.actions.ballparks.StoreSlimItemAttributeToBlackboard', dict(targetAddress=attributes.BlackboardAddressAttribute(), messageAddress=attributes.BlackboardAddressAttribute(), attributeName=attributes.StringAttribute()))
register_action('behaviors.actions.ballparks.FindPointToEscapeWarpTo', dict(locationMessage=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.FindPointToExplore', dict(locationMessage=attributes.BlackboardAddressAttribute(index=1), groupsOfInterest=attributes.InventoryGroupSetAttribute(index=2), categoriesOfInterest=attributes.InventoryCategorySetAttribute(index=3, is_optional=True), avoidUnsafeLocationsInEmpireSpace=attributes.BooleanAttribute(index=4, is_optional=True), pickSpecificChance=attributes.FloatAttribute(index=5), dungeonArchetypesOfInterest=attributes.DungeonArchetypeListAttribute(index=6, is_optional=True), dungeonsOfInterest=attributes.DungeonListAttribute(index=7, is_optional=True), shouldConsiderUnspawnedDungeons=attributes.BooleanAttribute(index=8, is_optional=True)))
register_action('behaviors.actions.ballparks.FindSpecificItemLocation', dict(locationMessageAddress=attributes.BlackboardAddressAttribute(index=1), itemsOfInterestAddress=attributes.BlackboardAddressAttribute(index=2), specificInterestTypelist=attributes.EveTypeListSelectAttribute(index=3), chosenItemOfInterestAddress=attributes.BlackboardAddressAttribute(index=4)))
register_action('behaviors.actions.ballparks.GetBallGotoPointAction', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), gotoPointAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.ManageMicroWarpDriveToTarget', dict(targetAddress=attributes.BlackboardAddressAttribute(), orbitRangeAddress=attributes.BlackboardAddressAttribute(), microWarpDriveDuration=attributes.IntegerAttribute(), microWarpDriveChance=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.ManageMicroWarpDriveToCoordinates', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), orbitRangeAddress=attributes.BlackboardAddressAttribute(), microWarpDriveDuration=attributes.IntegerAttribute(), microWarpDriveChance=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.ModifyOrbitVelocity', dict(orbitVelocity=attributes.FloatAttribute()))
register_action('behaviors.actions.ballparks.SelectClosestItemAndTypeByEveTypeList', dict(eveTypeListId=attributes.EveTypeListSelectAttribute(index=0), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=1), selectedTypeAddress=attributes.BlackboardAddressAttribute(index=2)), short_description='Select the closest object (ID and type) in bubble matching a type list.', detailed_description='Select the closest object in the current bubble that matches the groups in [groupIds]. Will succeed if an object is found and post the item ID to [selectedTargetAddress] and the objects typeID to [selectedTypeAddress] in the blackboard. Will also succeed (with out blackboard update) if there is already a in item in [selectedTargetAddress] which is still present in the bubble. If no item is found the task fails.')
register_action('behaviors.actions.ballparks.SelectClosestItemByEveTypeList', dict(eveTypeListId=attributes.EveTypeListSelectAttribute(index=0), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Select the closest object (ID) in bubble matching a type list.', detailed_description='Select the closest object in the current bubble that matches the groups in [groupIds]. Will succeed if an object is found and post the item ID to [selectedTargetAddress] in the blackboard. Will also succeed (with out blackboard update) if there is already a in item in [selectedTargetAddress] which is still present in the bubble. If no item is found the task fails.')
register_action('behaviors.actions.ballparks.GetBallLocation', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), coordinateAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.AlignToCoordinatesAction', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), timeoutSeconds=attributes.FloatAttribute(is_optional=True), acceptableAngleDeviationDegrees=attributes.FloatAttribute(is_optional=True)))
register_action('behaviors.actions.ballparks.PostOwnPosition', dict(coordinateAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.GetItemIdsInBubbleWithinRange', dict(ballsWithinRangeAddress=attributes.BlackboardAddressAttribute(index=0), maxDistance=attributes.FloatAttribute(index=1, is_optional=True), maxDistanceAddress=attributes.BlackboardAddressAttribute(index=2, is_optional=True), centerBallAddress=attributes.BlackboardAddressAttribute(index=3, is_optional=True), categoriesOfInterest=attributes.InventoryCategorySetAttribute(index=4, is_optional=True), groupsOfinterest=attributes.InventoryGroupSetAttribute(index=5, is_optional=True)))
register_action('behaviors.actions.ballparks.GetWarpBubbleItemIdsBlockingMeFromWarp', dict(itemIdSetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.ballparks.SelectCoordinatesFromDirectionIntoDistance', dict(directionAddress=attributes.BlackboardAddressAttribute(index=0), distance=attributes.FloatAttribute(index=1), coordinatesAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.ballparks.GetCoordinatesReducedByDistance', dict(sourceCoordinateAddress=attributes.BlackboardAddressAttribute(index=0), destinationCoordinateAddress=attributes.BlackboardAddressAttribute(index=1), distanceAddress=attributes.BlackboardAddressAttribute(index=2, is_optional=True)))
register_action('behaviors.actions.ballparks.FlyIntoRandomDirection', dict(velocityFraction=attributes.FloatAttribute()), short_description='Pick a random direction and fly there.', detailed_description='Picks a random vector and starts flying in that direction with speed equal to the maximum velocity times the requested speed fraction (0-1].')
register_action('behaviors.actions.ballparks.SelectAllItemIdsInBubbleByTypeList', dict(typeListId=attributes.EveTypeListSelectAttribute(index=0), selectedTargetsAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Select the items ids of objects in bubble matching a type list.', detailed_description='Selects all objects matching a type list [typeListId] and posts the item ids to blackboard at [selectedTargetsAddress]')
register_action('behaviors.actions.ballparks.CountItemsInBubbleByTypeList', dict(typeListId=attributes.EveTypeListSelectAttribute(index=0), itemCountAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Count the objects in bubble matching a type list', detailed_description='Counts all objects matching a type list [typeListId] and posts the number to blackboard at [selectedTargetsAddress]')
register_action('behaviors.actions.battlefield.AnalyzeBattlefieldFleetMatching', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0), spawnTableIdAddress=attributes.BlackboardAddressAttribute(index=1), spawnPointMultiplierAddress=attributes.BlackboardAddressAttribute(index=2), minimumSpawnPoints=attributes.IntegerAttribute(index=3), maximumSpawnPoints=attributes.IntegerAttribute(index=4), entityGroupIdAddressByFleetType=attributes.BlackboardAddressByFleetTypeAttribute(index=5), playerFleetReportAddress=attributes.BlackboardAddressAttribute(index=6), fleetMatchResultsAddress=attributes.BlackboardAddressAttribute(index=7)))
register_action('behaviors.actions.battlefield.CalculateStructureSpawnPointMultiplier', dict(spawnPointMultiplierAddress=attributes.BlackboardAddressAttribute(index=0), minSpawnPointMultiplier=attributes.FloatAttribute(index=1), maxSpawnPointMultiplier=attributes.FloatAttribute(index=2), peakHealthFraction=attributes.FloatAttribute(index=3)))
register_action('behaviors.actions.battlefield.SelectFleetToCounter', dict(fleetMatchResultsAddress=attributes.BlackboardAddressAttribute(index=0), fleetTypeToCounterAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardSendMyItemIdMessageAction', dict(messageAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSendMyEntityGroupIdMessageAction', dict(messageAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardClearBooleanFlags', dict(flagAddressList=attributes.BlackboardAddressListAttribute()))
register_action('behaviors.actions.blackboards.BlackboardCopyMessageAction', dict(sourceMessageAddress=attributes.BlackboardAddressAttribute(), targetMessageAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetBooleanFlags', dict(flagAddressList=attributes.BlackboardAddressListAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetMessageAsNoneAction', dict(messageAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetMessageToBooleanValueAction', dict(messageAddress=attributes.BlackboardAddressAttribute(), value=attributes.BooleanAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetMessageToIntegerValueAction', dict(messageAddress=attributes.BlackboardAddressAttribute(), value=attributes.IntegerAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetMessageToFloatValueAction', dict(messageAddress=attributes.BlackboardAddressAttribute(), value=attributes.FloatAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSetMessageToStringValueAction', dict(messageAddress=attributes.BlackboardAddressAttribute(), value=attributes.StringAttribute()))
register_action('behaviors.actions.blackboards.BlackboardSendItemBubbleIdMessage', dict(itemIdSourceAddress=attributes.BlackboardAddressAttribute(), bubbleIdTargetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardIncrementCounter', dict(counterAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardDecrementCounter', dict(counterAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.blackboards.BlackboardAddNumericValues', dict(firstValueAddress=attributes.BlackboardAddressAttribute(index=0), secondValueAddress=attributes.BlackboardAddressAttribute(index=1), resultValueAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardMergeCollectionsIntoSet', dict(firstCollectionAddress=attributes.BlackboardAddressAttribute(index=0), secondCollectionAddress=attributes.BlackboardAddressAttribute(index=1), resultSetAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardRemoveCollectionFromSet', dict(collectionAddress=attributes.BlackboardAddressAttribute(index=0), targetSetAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardAddBlackboardValueIntoBlackboardCollection', dict(valueAddress=attributes.BlackboardAddressAttribute(index=0), collectionAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardAddValueByKeyIntoBlackboardDictionary', dict(keyAddress=attributes.BlackboardAddressAttribute(index=0), valueAddress=attributes.BlackboardAddressAttribute(index=1), dictionaryAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardSetValueByKeyInBlackboardDictionary', dict(keyAddress=attributes.BlackboardAddressAttribute(index=0), valueAddress=attributes.BlackboardAddressAttribute(index=1), dictionaryAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardSetValueBySelfTypeInBlackboardDictionary', dict(valueAddress=attributes.BlackboardAddressAttribute(index=0), dictionaryAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardAddSelfByKeyIntoBlackboardDictionary', dict(keyAddress=attributes.BlackboardAddressAttribute(index=0), dictionaryAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardAddValueBySelfIntoBlackboardDictionary', dict(valueAddress=attributes.BlackboardAddressAttribute(index=0), dictionaryAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardRemoveValueByKeyFromBlackboardDictionary', dict(keyAddress=attributes.BlackboardAddressAttribute(index=0), valueAddress=attributes.BlackboardAddressAttribute(index=1), dictionaryAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardCopyValueBySelfTypeFromBlackboardDictionary', dict(sourceMessageAddress=attributes.BlackboardAddressAttribute(index=0), targetMessageAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BlackboardSetBooleanFlagsOnGroupRemoval', dict(messageAddressList=attributes.BlackboardAddressListAttribute(index=0), value=attributes.BooleanAttribute(index=1), oneShotAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.blackboards.BlackboardSetDictionaryValueByMyGroupId', dict(valueAddress=attributes.BlackboardAddressAttribute(index=0), dictionaryAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.blackboards.BroadcastBlackboardValueToBlackboards', dict(valueAddress=attributes.BlackboardAddressAttribute(index=0, description='The address of value to broadcast.'), targetAddress=attributes.BlackboardAddressAttribute(index=1, description='The address of the blackboard value to update when broadcasting blackboard updates.'), objectIdsAddress=attributes.BlackboardAddressAttribute(index=2, description='Blackboard address that contains the IDs of the recipient blackboards. IDs must match the scope of the targetAddress.')), short_description='Broadcast value from blackboard to other blackboards', detailed_description='Broadcast values from own blackboard to remote blackboards based on a list of IDs matching the target address')
register_action('behaviors.actions.combat.ActivateSuperWeaponOnTarget', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combat.AddCharacterForPodding', dict(characterAddress=attributes.BlackboardAddressAttribute(), poddingTargetListAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combat.KamikazeAttack', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute(), shouldAbortAddress=attributes.BooleanAttribute()))
register_action('behaviors.actions.combat.ActivateCombatEffectsOnTarget', dict(effectIds=attributes.DogmaEffectIdSetAttribute(index=1), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=2), repeat=attributes.IntegerAttribute(index=3), reactionDelayMilliseconds=attributes.IntegerAttribute(index=4, is_optional=True)))
register_action('behaviors.actions.combat.StopCombatEffectsOnTarget', dict(effectIds=attributes.DogmaEffectIdSetAttribute()))
register_action('behaviors.actions.combat.OwnerListFilterAction', dict(ownerIdSet=attributes.OwnerIdSetAddressAttribute(), itemIdSetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combat.GetCombatEffectsForRole', dict(roleAddress=attributes.BlackboardAddressAttribute(), combatEffectsAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combatmodules.ActivateModuleTypeOnTarget', dict(moduleAddress=attributes.BlackboardAddressAttribute(index=0), targetAddress=attributes.BlackboardAddressAttribute(index=1), repeats=attributes.IntegerAttribute(index=2), min_cycles=attributes.IntegerAttribute(index=3, default=0, is_optional=True), max_cycles=attributes.IntegerAttribute(index=4, default=0, is_optional=True)))
register_action('behaviors.actions.combatmodules.FindAndRegisterModule', dict(moduleAddress=attributes.BlackboardAddressAttribute(index=0), moduleTypeId=attributes.InventoryTypeSelectAttribute(index=1), registeredModulesAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.combatmodules.FilterItemsWithModules', dict(sourceItemSetAddress=attributes.BlackboardAddressAttribute(index=0), targetItemSetAddress=attributes.BlackboardAddressAttribute(index=1), typeListId=attributes.EveTypeListSelectAttribute(index=2)))
register_action('behaviors.actions.combatnavigation.GetCombatOrbitAndAttackRange', dict(orbitRangeAddress=attributes.BlackboardAddressAttribute(index=0), attackRangeAddress=attributes.BlackboardAddressAttribute(index=1), minOptimalAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=3), minFalloffAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=4), orbitRange=attributes.FloatAttribute(default=0.0, is_optional=True, index=5), attackRange=attributes.FloatAttribute(default=0.0, is_optional=True, index=6)))
register_action('behaviors.actions.combatnavigation.GetTargetToOrbit', dict(commanderAddress=attributes.BlackboardAddressAttribute(), combatTargetAddress=attributes.BlackboardAddressAttribute(), orbitTargetAddress=attributes.BlackboardAddressAttribute(), roleAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combatnavigation.GetFleetCombatOrbitRangeByRole', dict(orbitRangeAddress=attributes.BlackboardAddressAttribute(), roleAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combatnavigation.GetCombatWarpAtDistance', dict(combatWarpAtDistanceAddress=attributes.BlackboardAddressAttribute(), combatOrbitRangeAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.FindTarget', dict(potentialTargetListAddress=attributes.BlackboardAddressAttribute(index=1), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=2), primaryTargetIdAddress=attributes.BlackboardAddressAttribute(index=3, is_optional=True), targetEvaluationFunction=attributes.TargetEvaluatorAttribute(index=4), roleAddress=attributes.BlackboardAddressAttribute(index=5, is_optional=True), shouldSpreadTargetsInFleet=attributes.BooleanAttribute(index=6, default=False), fleetTargetsByGroupAddress=attributes.BlackboardAddressAttribute(index=7, is_optional=True), preferredModuleGroups=attributes.InventoryGroupSetAttribute(index=8, is_optional=True), includedCategories=attributes.InventoryCategorySetAttribute(index=9), onlyCheckLocalBubble=attributes.BooleanAttribute(index=10), bubbleIdAddress=attributes.BlackboardAddressAttribute(index=11, is_optional=True), guardObjectIdAddress=attributes.BlackboardAddressAttribute(index=12, is_optional=True), maxDistanceFromGuardObject=attributes.FloatAttribute(index=13, is_optional=True), threatSampleIntervalSeconds=attributes.IntegerAttribute(index=14, default=10)))
register_action('behaviors.actions.combattargets.FindTargetForModule', dict(potentialTargetListAddress=attributes.BlackboardAddressAttribute(), potentialTargetDictionaryAddress=attributes.BlackboardAddressAttribute(is_optional=True), selectedTargetAddress=attributes.BlackboardAddressAttribute(), targetEvaluationFunction=attributes.TargetEvaluatorAttribute(), includedCategories=attributes.InventoryCategorySetAttribute(), onlyCheckLocalBubble=attributes.BooleanAttribute(), bubbleIdAddress=attributes.BlackboardAddressAttribute(is_optional=True), primaryTargetIdAddress=attributes.BlackboardAddressAttribute(is_optional=True), roleAddress=attributes.BlackboardAddressAttribute(is_optional=True), preferredModuleGroups=attributes.InventoryGroupSetAttribute(is_optional=True), moduleAddress=attributes.BlackboardAddressAttribute(), nonStackableEveTypeListId=attributes.EveTypeListSelectAttribute(is_optional=True), targetsByModulesAddress=attributes.BlackboardAddressAttribute(), guardObjectIdAddress=attributes.BlackboardAddressAttribute(is_optional=True), maxDistanceFromGuardObject=attributes.FloatAttribute(is_optional=True), threatSampleIntervalSeconds=attributes.IntegerAttribute(default=10)))
register_action('behaviors.actions.combattargets.FindTargetWithPolarizedPreference', dict(potentialTargetListAddress=attributes.BlackboardAddressAttribute(index=1), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=2), primaryTargetIdAddress=attributes.BlackboardAddressAttribute(index=3, is_optional=True), targetEvaluationFunction=attributes.TargetEvaluatorAttribute(index=4), roleAddress=attributes.BlackboardAddressAttribute(index=5, is_optional=True), shouldSpreadTargetsInFleet=attributes.BooleanAttribute(index=6, default=False), fleetTargetsByGroupAddress=attributes.BlackboardAddressAttribute(index=7, is_optional=True), preferredModuleGroups=attributes.InventoryGroupSetAttribute(index=8, is_optional=True), includedCategories=attributes.InventoryCategorySetAttribute(index=9), onlyCheckLocalBubble=attributes.BooleanAttribute(index=10), bubbleIdAddress=attributes.BlackboardAddressAttribute(index=11, is_optional=True), isPreferenceEnabledAddress=attributes.BlackboardAddressAttribute(index=12), chanceOfPreferringTypesAddress=attributes.BlackboardAddressAttribute(index=13), preferredTypeBiasAmountAddress=attributes.BlackboardAddressAttribute(index=14), preferredTypeListID=attributes.EveTypeListSelectAttribute(index=15), isPreferringTypeAddress=attributes.BlackboardAddressAttribute(index=16), guardObjectIdAddress=attributes.BlackboardAddressAttribute(index=17, is_optional=True), maxDistanceFromGuardObject=attributes.FloatAttribute(index=18, is_optional=True), threatSampleIntervalSeconds=attributes.IntegerAttribute(index=19, default=10)))
register_action('behaviors.actions.combattargets.AcquireTargetLock', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.AcquireTargetLockNonBlocking', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.UnlockTarget')
register_action('behaviors.actions.combattargets.UnlockModuleTarget', dict(moduleAddress=attributes.BlackboardAddressAttribute(), targetsByModulesAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.ClearTargetSet', dict(targetSetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.PruneNpcsFromTargetSet', dict(targetSetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.combattargets.SelectPilotedShips', dict(sourceSetAddress=attributes.BlackboardAddressAttribute(index=1), targetSetAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.combattargets.GetMyMinOptimalAndFalloff', dict(minOptimalAddress=attributes.BlackboardAddressAttribute(index=0), minFalloffAddress=attributes.BlackboardAddressAttribute(index=1), combatEffectsAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.combattargets.GetMaxEffectiveRange', dict(maxEffectiveRangeAddress=attributes.BlackboardAddressAttribute(index=0), minOptimalAddress=attributes.BlackboardAddressAttribute(index=1), minFalloffAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.combattargets.GenerateTargetSetsByCombatRangesInGroup', dict(targetsByEntityTypeAddress=attributes.BlackboardAddressAttribute(index=0), rangeByEntityTypeAddress=attributes.BlackboardAddressAttribute(index=1), commanderAddress=attributes.BlackboardAddressAttribute(index=2), threatTargetSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=3)))
register_action('behaviors.actions.combattargets.GetPrimaryAndNonPrimaryTargetsByEntityTypes', dict(targetsAddress=attributes.BlackboardAddressAttribute(index=0), primaryTargetsByEntityTypesAddress=attributes.BlackboardAddressAttribute(index=1), primaryTargetEvaluationFunction=attributes.TargetEvaluatorAttribute(index=2), primaryTypeListId=attributes.EveTypeListSelectAttribute(is_optional=True, index=3), nonPrimaryTargetsByEntityTypesAddress=attributes.BlackboardAddressAttribute(index=4), nonPrimaryTargetEvaluationFunction=attributes.TargetEvaluatorAttribute(index=5), nonPrimaryTypeListId=attributes.EveTypeListSelectAttribute(is_optional=True, index=6)))
register_action('behaviors.actions.combattargets.GetWeightedTargetFromTargetsSet', dict(targetIdAddress=attributes.BlackboardAddressAttribute(index=0), targetWeightSetAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.combattargets.DisengageObsoleteTargets', dict(myTargetAddress=attributes.BlackboardAddressAttribute(index=0), myCombatEffectsAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.combattargets.FindHostileStructureInRange', dict(targetsAddress=attributes.BlackboardAddressAttribute(index=0), minDistance=attributes.FloatAttribute(index=1)))
register_action('behaviors.actions.damage.SetArmorRatio', dict(armorRatio=attributes.FloatAttribute()))
register_action('behaviors.actions.damage.SetShieldRatio', dict(shieldRatio=attributes.FloatAttribute()))
register_action('behaviors.actions.damage.SetStructureRatio', dict(structureRatio=attributes.FloatAttribute()))
register_action('behaviors.actions.damage.SetArmorRatioForItem', dict(armorRatio=attributes.FloatAttribute(), itemIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.damage.SetShieldRatioForItem', dict(shieldRatio=attributes.FloatAttribute(), itemIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.damage.SetStructureRatioForItem', dict(structureRatio=attributes.FloatAttribute(), itemIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.damage.DealDamageOutsideOfArea', dict(minDamageDistance=attributes.FloatAttribute(index=1), maxDamageDistance=attributes.FloatAttribute(index=2), areaDamageFactor=attributes.FloatAttribute(index=3, default=1.0), emDamage=attributes.IntegerAttribute(index=4), explosiveDamage=attributes.IntegerAttribute(index=5), kineticDamage=attributes.IntegerAttribute(index=6), thermalDamage=attributes.IntegerAttribute(index=7)))
register_action('behaviors.actions.damage.DisplayCholesterolField', dict(defaultDistance=attributes.IntegerAttribute(index=1), distanceAddress=attributes.BlackboardAddressAttribute(index=2, is_optional=True)))
register_action('behaviors.actions.drones.SpawnDrones', dict(behaviorTreeName=attributes.BehaviorItemTreeAttribute(is_optional=True, index=0), behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=1), droneTypeId=attributes.InventoryTypeAttribute(index=2), droneGroupIdAddress=attributes.BlackboardAddressAttribute(index=3), maxDroneCountAddress=attributes.BlackboardAddressAttribute(index=4), maxDroneActiveCountAddress=attributes.BlackboardAddressAttribute(index=5), dronesSpawnedCountAddress=attributes.BlackboardAddressAttribute(index=6), shouldSelfDestructOnControllerDeath=attributes.BooleanAttribute(default=False, index=7), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=8)))
register_action('behaviors.actions.drones.AssignTargetToDroneGroup', dict(droneGroupIdAddress=attributes.BlackboardAddressAttribute(index=0), targetIdAddress=attributes.BlackboardAddressAttribute(index=1)))
register_action('behaviors.actions.dungeon.GetDungeonSpawnEntryPoint', dict(dungeonSpawnIdAddress=attributes.BlackboardAddressAttribute(description='The address of the dungeon spawn id to get the entry point for'), dungeonEntryCoordinatesAddress=attributes.BlackboardAddressAttribute(description='The coordinates of the entry point')), short_description='Get get the entry point of a dungeon spawn', detailed_description='Get the entry point of a dungeon spawn identified in a blackboard and write as a coordinate back to the blackboard.')
register_action('behaviors.actions.dungeon.SelectTeamMembersInRange', dict(maxDistanceAddress=attributes.BlackboardAddressAttribute(), referenceItemIdAddress=attributes.BlackboardAddressAttribute(), entityGroupsByTeamNameAddress=attributes.BlackboardAddressAttribute(), teamNameAddress=attributes.BlackboardAddressAttribute(), selectedItemsAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.dungeon.SetContextDungeonSpawnId', dict(dungeonSpawnIdAddress=attributes.BlackboardAddressAttribute()), short_description='Set the spawn id as the behaviors dungeon context', detailed_description='Take a dungeon spawn id from the blackboard and set as the acting behaviors dungeon context. This will give the behavior access to the dungeon blackboard for the indicated dungeon spawn.  It will lose access to the current dungeon blackboard if different.')
register_action('behaviors.actions.dungeon.RegisterEntityGroupsByTeamName', dict(teamNameAddress=attributes.BlackboardAddressAttribute(), entityGroupsByTeamNameAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.dungeon.GetItemIdForDungeonObject', dict(objectIdAddress=attributes.BlackboardAddressAttribute(index=0), itemIdAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Get the itemID for a dungeon object by ID', detailed_description='Will get the the spawned item ID for dungeon object by ID.  Uses the dungeon spawn references by the item itself.')
register_action('behaviors.actions.effects.ActivateDefaultEffect', dict(repeats=attributes.IntegerAttribute(), contextDict=attributes.StringToLiteralDictionaryAttribute()))
register_action('behaviors.actions.effects.ActivateEffect', dict(effectId=attributes.DogmaEffectIdAttribute(), repeats=attributes.IntegerAttribute(), contextDict=attributes.StringToLiteralDictionaryAttribute()))
register_action('behaviors.actions.effects.ActivateTargetedEffect', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute(index=0), effectId=attributes.DogmaEffectIdAttribute(index=1), repeats=attributes.IntegerAttribute(index=2), shouldResetBehaviorOnEffectStopped=attributes.BooleanAttribute(index=3, default=False)))
register_action('behaviors.actions.effects.PlayOneShotStretchEffectAction', dict(effectDuration=attributes.FloatAttribute(), effectName=attributes.GraphicEffectNameAttribute(), effectSourceAddress=attributes.BlackboardAddressAttribute(is_optional=True), effectTargetAddress=attributes.BlackboardAddressAttribute(), useEntityAsModule=attributes.BooleanAttribute(is_optional=True), effectDurationAddress=attributes.BlackboardAddressAttribute(is_optional=True)))
register_action('behaviors.actions.effects.PlayOneShotTargetedShipEffectAction', dict(effectDuration=attributes.FloatAttribute(), effectName=attributes.GraphicEffectNameAttribute(), effectTargetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.effects.PlayOneShotShipEffectAction', dict(effectDuration=attributes.FloatAttribute(), effectName=attributes.GraphicEffectNameAttribute(), effectTargetAddress=attributes.BlackboardAddressAttribute(is_optional=True), graphicInfo=attributes.StringToLiteralDictionaryAttribute()))
register_action('behaviors.actions.effects.SetDogmaAttributeValue', dict(attributeId=attributes.DogmaAttributeAttribute(), value=attributes.FloatAttribute()))
register_action('behaviors.actions.effects.SendDogmaAttributeValueAsMessage', dict(attributeId=attributes.DogmaAttributeAttribute(), valueAddress=attributes.BlackboardAddressAttribute(), scalar=attributes.FloatAttribute(is_optional=True)))
register_action('behaviors.actions.effects.ResetDogmaAttributeValue', dict(attributeId=attributes.DogmaAttributeAttribute()))
register_action('behaviors.actions.effects.PlayStretchEffectAction', dict(effectName=attributes.GraphicEffectNameAttribute(index=0), effectDuration=attributes.FloatAttribute(index=1), effectRepeats=attributes.IntegerAttribute(index=2), effectTargetAddress=attributes.BlackboardAddressAttribute(index=3), useEntityAsModule=attributes.BooleanAttribute(is_optional=True, index=4), graphicInfoAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=5), effectDurationRandomVariance=attributes.IntegerAttribute(is_optional=True, index=6, description='allows the duration do deviate from the default')))
register_action('behaviors.actions.effects.StopStretchEffectAction', dict(effectName=attributes.GraphicEffectNameAttribute(), effectTargetAddress=attributes.BlackboardAddressAttribute(), useEntityAsModule=attributes.BooleanAttribute(is_optional=True)))
register_action('behaviors.actions.effects.MockTargetAttack', dict(targetIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.effects.StopMockTargetAttack', dict(targetIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.effects.SendDogmaEffectIdAsMessage', dict(effectId=attributes.DogmaEffectIdAttribute(), effectIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.effects.StopEffect', dict(effectId=attributes.DogmaEffectIdAttribute(index=0), forcedStop=attributes.BooleanAttribute(default=False, index=1)))
register_action('behaviors.actions.effects.ReplaceNebulaForPlayersInBubble')
register_action('behaviors.actions.entities.AddTypeAndAmountToAdditionalLoot', dict(typeIdAddress=attributes.BlackboardAddressAttribute(), amount=attributes.IntegerAttribute(), allowOverload=attributes.BooleanAttribute()))
register_action('behaviors.actions.entities.AddBlackboardTypeAndBlackboardAmountToAdditionalLoot', dict(typeIdAddress=attributes.BlackboardAddressAttribute(), amountAddress=attributes.BlackboardAddressAttribute(), allowOverload=attributes.BooleanAttribute()))
register_action('behaviors.actions.entities.RemoveTypesFromAdditionalLoot', dict(typeIds=attributes.InventoryTypeSetAttribute()))
register_action('behaviors.actions.entities.MoveAdditionalLootBetweenEntities', dict(entityIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.entities.SelectGroupLeaderAction', dict(groupLeaderIdAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.entities.UnspawnSelf')
register_action('behaviors.actions.entities.DestroySelf')
register_action('behaviors.actions.entities.UpdateStandingThresholdsForEntity', dict(hostileResponseThreshold=attributes.FloatAttribute(index=1), friendlyResponseThreshold=attributes.FloatAttribute(index=2)))
register_action('behaviors.actions.entities.UpdateFwAttackMethodForEntity', dict(fwAttackMethod=attributes.FwAttackMethodAttribute(index=1, is_optional=True), groupStandingsDisabled=attributes.BooleanAttribute(index=2, is_optional=True, default=False)))
register_action('behaviors.actions.entities.CountBehaviorEntitiesOfTypeInSystem', dict(typeIDsToCount=attributes.InventoryTypeSetAttribute(index=1), resultAddress=attributes.BlackboardAddressAttribute(index=2)), short_description='Counts items in solarsystem by typeID', detailed_description='Counts items in the same solarsystem that are of a typeID that is in typeIDsToCount.The results get posted to resultAddress.')
register_action('behaviors.actions.entityspawning.DisableRespawnGroup', dict())
register_action('behaviors.actions.entityspawning.SetSelfEntityRespawn', dict(minRespawnDelaySeconds=attributes.IntegerAttribute(index=1), maxRespawnDelaySeconds=attributes.IntegerAttribute(index=2), deploymentRangeMeters=attributes.IntegerAttribute(index=3)))
register_action('behaviors.actions.entityspawning.SetSpawnPoolAmount', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0), spawnPointAmount=attributes.IntegerAttribute(index=1)), short_description='Set the spawn point amount for a Spawn Pool', detailed_description='Sets the spawn pool amount for an existing spawn pool as specified by in the blackboard by spawnPoolIdAddress.')
register_action('behaviors.actions.entityspawning.SpawnNewEntities', dict(behaviorTreeName=attributes.BehaviorItemTreeAttribute(is_optional=True, index=0), behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=1), entities=attributes.EntitiesAndQuantitiesAttribute(index=2), spawnNewGroup=attributes.BooleanAttribute(default=False, index=3), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=4), spawnPositionAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=5), deploymentRange=attributes.FloatAttribute(is_optional=True, index=6), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=7), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=8), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=9), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=10)), short_description='Spawn entities based on type IDs and quantities', detailed_description='Spawn specific entities and quantities.')
register_action('behaviors.actions.entityspawning.SpawnNewEntitiesAtStructureFromSpawnTable', dict(behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=0), spawnTableIdAddress=attributes.BlackboardAddressAttribute(index=1), spawnPoints=attributes.IntegerAttribute(index=2, is_optional=True), spawnPoolIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=3), npcTagList=attributes.NpcTagListAttribute(index=4), structureIdAddress=attributes.BlackboardAddressAttribute(index=5), spawnNewGroup=attributes.BooleanAttribute(default=False, index=6), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=7), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=8), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=9), maxNpcCount=attributes.IntegerAttribute(is_optional=True, index=10), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=11), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=12)))
register_action('behaviors.actions.entityspawning.SpawnNewEntitiesBySpawnlistAndOwnerId', dict(behaviorTreeName=attributes.BehaviorItemTreeAttribute(is_optional=True, index=0), behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=1), spawnNewGroup=attributes.BooleanAttribute(default=False, index=2), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=3), spawnPositionAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=4), deploymentRange=attributes.FloatAttribute(is_optional=True, index=5), highSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=6), lowSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=7), zeroSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=8), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=9), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=10), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=11), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=12)))
register_action('behaviors.actions.entityspawning.SetSpawnTableOnBlackboardByOwner', dict(spawnTableIdAddress=attributes.BlackboardAddressAttribute(index=1), ownerToSpawnTableMapping=attributes.OwnerIdToSpawnTableIdDictionaryAttribute(index=2)), short_description='Assign a Spawn Table ID to the blackboard based on the behavior owner.', detailed_description='Will assign a Spawn Table ID to blackboard using the owner ID of the behaving entities entity group owner or falling back on the item owner ID.')
register_action('behaviors.actions.entityspawning.RegisterSpawnPool', dict(maxSpawnPoints=attributes.IntegerAttribute(index=0), initialSpawnPoints=attributes.IntegerAttribute(is_optional=True, index=1), spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=2)), short_description='Create a new Spawn Pool', detailed_description='Creates a new Spawn Pool with a maximum allowed spawn points. The Spawn Pool ID is stored in the blackboard. You can provide an initial amount of spawn points.')
register_action('behaviors.actions.entityspawning.SendSpawnTableIdToBlackboard', dict(npcSpawnTableId=attributes.NpcSpawnTableIdAttribute(index=0), npcSpawnTableIdAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Assigns a specific Spawn Table ID to a blackboard address', detailed_description='The npcSpawnTableId is posted to the blackboard at npcSpawnTableIdAddress')
register_action('behaviors.actions.entityspawning.SpawnEntitiesFromSpawnTable', dict(behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=0), spawnTableIdAddress=attributes.BlackboardAddressAttribute(index=1), spawnPoints=attributes.IntegerAttribute(is_optional=True, index=2), spawnPoolIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=3), npcTagList=attributes.NpcTagListAttribute(index=4), spawnNewGroup=attributes.BooleanAttribute(default=False, index=5), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=6), spawnPositionAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=7), deploymentRange=attributes.FloatAttribute(is_optional=True, index=8), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=9), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=10), maxNpcCount=attributes.IntegerAttribute(is_optional=True, index=11), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=12), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=13)), short_description='Spawn entities from a spawn table, stand-alone or from a spawn pool', detailed_description='You can spawn using just spawn points and a spawn table id set. Supports spawning based on given spawn point amounts or based on points from a spawn pool. We can create a new group or spawn into an existing one if available. The action can track all created entity group ids if needed. The simplest way to spawn is to only set behaviorTreeGroupName, spawnTableIDAddress and spawnPoints to spawn a group in deep-space. Atm there is no simple way of monitoring when the entity group has been destroyed.')
register_action('behaviors.actions.entityspawning.SpawnNewEntitiesAtStructure', dict(behaviorTreeName=attributes.BehaviorItemTreeAttribute(is_optional=True, index=0), behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=1), entities=attributes.EntitiesAndQuantitiesAttribute(index=2), structureIdAddress=attributes.BlackboardAddressAttribute(index=3), spawnNewGroup=attributes.BooleanAttribute(default=False, index=4), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=5), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=6), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=7), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=8), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=9)), short_description='Spawn entities from structure with undock from a spawn table, stand-alone or from a spawn pool ', detailed_description='You can spawn using just spawn points and a spawn table id set. Supports spawning based on given spawn point amounts or based on points from a spawn pool. The entities will be spawned from the undock of a structure. We can create a new group or spawn into an existing one if available. The action can track all created entity group ids if needed. The simplest way to spawn is to only set behaviorTreeGroupName, spawnTableIDAddress and spawnPoints to spawn a group in deep-space. Atm there is no simple way of monitoring when the entity group has been destroyed.')
register_action('behaviors.actions.entityspawning.SpawnNewEntitiesAtStructureBySpawnlistAndOwnerId', dict(behaviorTreeName=attributes.BehaviorItemTreeAttribute(is_optional=True, index=0), behaviorTreeGroupName=attributes.BehaviorGroupTreeAttribute(is_optional=True, index=1), structureIdAddress=attributes.BlackboardAddressAttribute(index=2), spawnNewGroup=attributes.BooleanAttribute(default=False, index=3), entityGroupSetAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=4), highSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=5), lowSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=6), zeroSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=7), entityGroupIdAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=8), guardObjectAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=9), bountyPayOutMultiplier=attributes.FloatAttribute(is_optional=True, index=10), objectiveTargetGroupAddress=attributes.BlackboardAddressAttribute(is_optional=True, index=11)), short_description='Spawn entities from structure with undock from a spawnlist based on owner and system sec', detailed_description='You can spawn using just spawn points and a spawn table id set. The entities spawned are based on a spawn list by owner per system security class.The entities will be spawned from the undock of a structure. We can create a new group or spawn into an existing one if available. The action can track all created entity group ids if needed. The simplest way to spawn is to only set behaviorTreeGroupName, Atm there is no simple way of monitoring when the entity group has been destroyed.')
register_action('behaviors.actions.entityspawning.ReactiveSpawning', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=1), spawnTableIdAddress=attributes.BlackboardAddressAttribute(index=2), npcFleetCounterTableId=attributes.NpcFleetCounterAttribute(index=3), initialPointAmount=attributes.IntegerAttribute(index=4, default=0), minPointAmount=attributes.IntegerAttribute(index=5), maxPointAmount=attributes.IntegerAttribute(index=6), threatRange=attributes.IntegerAttribute(index=7), threatTimeoutSeconds=attributes.IntegerAttribute(index=8), trackedTypeListID=attributes.EveTypeListSelectAttribute(index=9), maxSensorDrift=attributes.IntegerAttribute(index=10), updateTimeSeconds=attributes.IntegerAttribute(index=11), combatTargetsSetAddress=attributes.BlackboardAddressAttribute(index=12), standingsEnabled=attributes.BooleanAttribute(index=13, default=True), minSpawnIntervalSeconds=attributes.IntegerAttribute(index=14), maxSpawnIntervalSeconds=attributes.IntegerAttribute(index=15), shouldMatchPlayerPoints=attributes.BooleanAttribute(index=16, default=True), spawnPointMultiplier=attributes.FloatAttribute(index=17, default=1.0), bountyPayoutMultiplier=attributes.FloatAttribute(index=18, default=1.0), spawnPointThreshold=attributes.IntegerAttribute(index=19), cappedSpawnPoints=attributes.BooleanAttribute(index=20), spawnWithoutThreats=attributes.BooleanAttribute(index=21), resetWithoutThreats=attributes.BooleanAttribute(index=22), reactToDisapproval=attributes.BooleanAttribute(index=23, default=False, is_optional=True), fwAttackMethod=attributes.FwAttackMethodAttribute(index=24, is_optional=True)))
register_action('behaviors.actions.fighterabilities.StopAbilityEffectOnTarget', dict(effectIDAddress=attributes.BlackboardAddressAttribute(), abilitySlotID=attributes.IntegerAttribute(), failureReasonAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.fighterabilities.ActivateAbilityEffectOnPoint', dict(targetPoint=attributes.BlackboardAddressAttribute(), effectIDAddress=attributes.BlackboardAddressAttribute(), abilitySlotID=attributes.IntegerAttribute(), failureReasonAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.fighterabilities.NotifyAbilityActivationFailure', dict(abilitySlotID=attributes.IntegerAttribute()))
register_action('behaviors.actions.fleet.FormationWarpGroup', dict(destinationCoordinatesAddress=attributes.BlackboardAddressAttribute(index=0, description='Coordinate of the warp destination'), additionalFleetMembersAddress=attributes.BlackboardAddressAttribute(index=1, description='Collection of additional item ids of players or behavior entities'), formationType=attributes.FleetFormationTypeAttribute(index=2, description='Fleet formation type'), formationSpacing=attributes.IntegerAttribute(index=3, description='Fleet formation spacing (meters)'), formationSize=attributes.IntegerAttribute(index=4, description='Fleet formation size (meters)')), short_description='Perform a fleet warp with NPCs and or Players', detailed_description='Perform a formation fleet warp with the members of your group along with additional players an/or behavior NPCs')
register_action('behaviors.actions.fleet.AlignFleet', dict(destinationCoordinatesAddress=attributes.BlackboardAddressAttribute(index=0, description='Coordinate of the align destination'), additionalFleetMembersAddress=attributes.BlackboardAddressAttribute(index=1, description='Collection of additional item ids of players or behavior entities')), short_description='Perform a fleet align with NPCs and or Players', detailed_description='Perform a fleet align with the members of your group along with additional players an/or behavior NPCs.  All ships align to the target and set speed to maximum.')
register_action('behaviors.actions.fleet.BlockWaitUntilWarpComplete', dict(), short_description='Block tree until ship exits warp', detailed_description='Block the tree so it cannot be reset while it finishes a warp.  Nothing good happens when we make AI decisions while warping. Careful this can get stuck if we never exit the warp')
register_action('behaviors.actions.fleet.WaitUntilWarpComplete', dict(), short_description='Wait tree until ship exits warp', detailed_description='Wait while item finishes a warp. Nothing good happens when we make AI decisions while warping. Careful this can get stuck if we never exit the warp')
register_action('behaviors.actions.group.UpdateMaxMemberCount', dict(maxMemberCountAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.group.UpdateCurrentMemberCount', dict(currentMemberCountAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.group.ChooseCommander', dict(commanderAddress=attributes.BlackboardAddressAttribute(index=0), requiredCommanderRole=attributes.CombatRoleAttribute(index=1, is_optional=True), invalidCommanderRoles=attributes.CombatRoleSetAttribute(index=2)))
register_action('behaviors.actions.group.GetMemberList', dict(memberListAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.group.AssignExtraLootTableByOwnerIdAndEntityGroupId', dict(additionalLootTablesAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.group.UnspawnGroup')
register_action('behaviors.actions.group.PostWeaponRangesForGroup', dict(maxEffectiveWeaponRangeAddress=attributes.BlackboardAddressAttribute(index=0), minEffectiveWeaponRangeAddress=attributes.BlackboardAddressAttribute(index=1), rolesToConsider=attributes.CombatRoleSetAttribute(index=2), entitiesByRole=attributes.BlackboardAddressAttribute(index=3)))
register_action('behaviors.actions.group.GetClosestPlayerBallToGroupLeader', dict(ballIdAddress=attributes.BlackboardAddressAttribute(index=0), commanderAddress=attributes.BlackboardAddressAttribute(index=1, is_optional=True)))
register_action('behaviors.actions.group.IsAnyPlayerShipOnGridWithGroupMember', dict(includeCloaked=attributes.BooleanAttribute(index=0), resultAddress=attributes.BlackboardAddressAttribute(index=1)), short_description='Checks if there are any player ships on grid with any of the group members and posts a boolean to resultAddress.', detailed_description='Checks if there are any player ships on grid with any of the group members and posts a boolean to resultAddress. Has a toggle "includeCloaked" that can be used to include/exclude cloaked/ships')
register_action('behaviors.actions.guard.PlaceProximitySensor', dict(itemIdAddress=attributes.BlackboardAddressAttribute(index=1), rangeAddress=attributes.BlackboardAddressAttribute(index=2), sensorReplacementRange=attributes.IntegerAttribute(index=3), tags=attributes.StringSetAttribute(is_optional=True, index=4)))
register_action('behaviors.actions.guard.PlaceProximitySensorForGroup', dict(rangeAddress=attributes.BlackboardAddressAttribute(index=1), sensorReplacementRange=attributes.IntegerAttribute(index=2), tags=attributes.StringSetAttribute(is_optional=True, index=3)))
register_action('behaviors.actions.hauling.GetHaulerPickUpDestination', dict(availableBallsAddress=attributes.BlackboardAddressAttribute(), chosenBallAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.hauling.AddMeToHaulerPickUpDestination', dict(availableBallsAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.eventlogger.LogTaskEvent', dict(behaviorEvent=attributes.StringAttribute()))
register_action('behaviors.actions.eventlogger.LogGroupDestruction', dict(combatTargetsAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.logistics.SelectDesiredAnchorPosition', dict(friendlyOwners=attributes.OwnerListAttribute(), hostileOwners=attributes.OwnerListAttribute(), desiredPositionAddress=attributes.BlackboardAddressAttribute(), proximityFraction=attributes.FloatAttribute()))
register_action('behaviors.actions.logistics.SelectGroupMemberBasedOnLowestAttributeValue', dict(selectedIdAddress=attributes.BlackboardAddressAttribute(), attributeId=attributes.DogmaAttributeAttribute()))
register_action('behaviors.actions.logistics.SetRearFleetPosition', dict(hostilePositionAddress=attributes.BlackboardAddressAttribute(), anchorBallIdAddress=attributes.BlackboardAddressAttribute(), distanceAddress=attributes.BlackboardAddressAttribute(), targetPositionAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.logistics.SetForwardFleetPosition', dict(hostilePositionAddress=attributes.BlackboardAddressAttribute(), anchorBallIdAddress=attributes.BlackboardAddressAttribute(), distanceAddress=attributes.BlackboardAddressAttribute(), targetPositionAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.logistics.PrioritizeLogisticsWatchlist', dict(watchlistAddress=attributes.BlackboardAddressAttribute(index=0), prioritizedWatchlistAddress=attributes.BlackboardAddressAttribute(index=1), remoteRepairEffectRegistryAddress=attributes.BlackboardAddressAttribute(index=2)))
register_action('behaviors.actions.logistics.LockPrioritizedWatchlistMembers', dict(prioritizedWatchlistAddress=attributes.BlackboardAddressAttribute(index=0), combatTargetAddress=attributes.BlackboardAddressAttribute(index=1, is_optional=True), remoteRepairEffectIdAddress=attributes.BlackboardAddressAttribute(index=2, is_optional=True, description='override auto discovery of effect ID')), short_description='Lock targets base on a prioritized list of logistics targets', detailed_description='Target lock multiple targets with in effective range based on a prioritized watchlist. Range to target based on the repair effect used is factored into the prioritization. The prioritized list is composed of tuples with (priority, targetID) priority generally expressed in the range [0-1.0] multiplied with the range falloff multiplier. Items outside useful range are ignored.  If the object has combat targets 1 target will be reserved for offensive effects. The default auto discovery of shield/armor NPC remote repair effect can be overridden using a blackboard value')
register_action('behaviors.actions.logistics.RegisterRepairEffectForType', dict(remoteRepairEffectRegistryAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.map.GetSolarSystemFactionID', dict(messageAddress=attributes.BlackboardAddressAttribute()), short_description='Post the current solar systems owning factionID to the blackboard.', detailed_description='Action that, when called, reads then writes the solar system ownerID into a behavior blackboard message.')
register_action('behaviors.actions.mathtasks.WriteVectorToBlackboard', dict(x=attributes.FloatAttribute(index=1), y=attributes.FloatAttribute(index=2), z=attributes.FloatAttribute(index=3), outputVectorAddress=attributes.BlackboardAddressAttribute(index=4)), short_description='Create a 3d vector in blackboard', detailed_description='')
register_action('behaviors.actions.mathtasks.AddToVectorInBlackboard', dict(x=attributes.FloatAttribute(index=1), y=attributes.FloatAttribute(index=2), z=attributes.FloatAttribute(index=3), inputVectorAddress=attributes.BlackboardAddressAttribute(index=4), outputVectorAddress=attributes.BlackboardAddressAttribute(index=5)), short_description='Add to a 3d vector in a blackboard and output back to blackboard', detailed_description='')
register_action('behaviors.actions.mathtasks.AddVectorsInBlackboard', dict(firstVectorAddress=attributes.BlackboardAddressAttribute(index=1), secondVectorAddress=attributes.BlackboardAddressAttribute(index=2), outputVectorAddress=attributes.BlackboardAddressAttribute(index=3)), short_description='Add two 3d vectors from blackboard and output result in back to blackboard', detailed_description='')
register_action('behaviors.actions.mathtasks.SubtractVectorsInBlackboard', dict(firstVectorAddress=attributes.BlackboardAddressAttribute(index=1), secondVectorAddress=attributes.BlackboardAddressAttribute(index=2), outputVectorAddress=attributes.BlackboardAddressAttribute(index=3)), short_description='Subtract 3d vector from blackboard from one another and output into blackboard', detailed_description='')
register_action('behaviors.actions.objectspawning.SpawnSpaceObjectsFromDungeon', dict(dungeonId=attributes.IntegerAttribute(index=1), object1TypeIdForReplacing=attributes.IntegerAttribute(index=2), object1MinCount=attributes.IntegerAttribute(index=3), object1MaxCount=attributes.IntegerAttribute(index=4), eveTypeList1=attributes.EveTypeListSelectAttribute(index=5), object2TypeIdForReplacing=attributes.IntegerAttribute(index=6), object2MinCount=attributes.IntegerAttribute(index=7), object2MaxCount=attributes.IntegerAttribute(index=8), eveTypeList2=attributes.EveTypeListSelectAttribute(index=9), object3TypeIdForReplacing=attributes.IntegerAttribute(index=10), object3MinCount=attributes.IntegerAttribute(index=11), object3MaxCount=attributes.IntegerAttribute(index=12), eveTypeList3=attributes.EveTypeListSelectAttribute(index=13)))
register_action('behaviors.actions.objectspawning.SpawnSpaceObject', dict(typeId=attributes.IntegerAttribute(index=0), coordinateAddress=attributes.BlackboardAddressAttribute(index=1, is_optional=True)))
register_action('behaviors.actions.objectspawning.SpawnPersistentSpaceObject', dict(typeId=attributes.IntegerAttribute(index=0), coordinateAddress=attributes.BlackboardAddressAttribute(index=1, is_optional=True)))
register_action('behaviors.actions.operations.GetOperationSiteSpawn', dict(characterIdAddress=attributes.BlackboardAddressAttribute(index=1), operationSiteId=attributes.OperationSiteAttribute(index=2, description='The operation site we are getting'), siteSolarSystemIdAddress=attributes.BlackboardAddressAttribute(index=3, description=''), siteSpawnIdAddress=attributes.BlackboardAddressAttribute(index=4), siteCoordinatesAddress=attributes.BlackboardAddressAttribute(index=5)), short_description='Get get spawn information for spawned characters operation site', detailed_description='Get the spawn details for an operation site for a particular character. The task will write the solar system id, dungeon spawn id and grid coordinates of target site into a blackboard if found.')
register_action('behaviors.actions.randomized.PostRandomIntegerToBlackboard', dict(blackboardAddress=attributes.BlackboardAddressAttribute(), minValue=attributes.IntegerAttribute(index=0), maxValue=attributes.IntegerAttribute(index=1)))
register_action('behaviors.actions.randomized.ScaleValueRandomized', dict(valueAddress=attributes.BlackboardAddressAttribute(index=1), minValue=attributes.IntegerAttribute(index=2), maxValue=attributes.IntegerAttribute(index=3)))
register_action('behaviors.actions.reference_subtree.ReferenceSubtree', dict(behaviorTreeId=attributes.BehaviorTreeAttribute(index=1), parameters=attributes.SubtreeParametersAttribute(index=2)))
register_action('behaviors.actions.reinforcements.CallInReinforcementsAction')
register_action('behaviors.actions.reinforcements.AddReinforcementsByOwnerId', dict(reinforcementThreshold=attributes.FloatAttribute(index=0), reinforcementWaveCooldownSeconds=attributes.IntegerAttribute(index=1), highSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=3), lowSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=4), zeroSecOwnerToSpawnlistMapping=attributes.OwnerIdToSpawnlistIdDictionaryAttribute(index=5), behaviorOverrideId=attributes.BehaviorItemTreeAttribute(index=6, is_optional=True)))
register_action('behaviors.actions.reinforcements.CallForUnspawningReinforcements')
register_action('behaviors.actions.resourcewars.ResourceWarsFindTarget', dict(potentialTargetListAddress=attributes.BlackboardAddressAttribute(index=1), selectedTargetAddress=attributes.BlackboardAddressAttribute(index=2), primaryTargetIdAddress=attributes.BlackboardAddressAttribute(index=3, is_optional=True), targetEvaluationFunction=attributes.TargetEvaluatorAttribute(index=4), roleAddress=attributes.BlackboardAddressAttribute(index=5, is_optional=True), shouldSpreadTargetsInFleet=attributes.BooleanAttribute(index=6, default=False), fleetTargetsByGroupAddress=attributes.BlackboardAddressAttribute(index=7, is_optional=True), preferredModuleGroups=attributes.InventoryGroupSetAttribute(index=8, is_optional=True), includedCategories=attributes.InventoryCategorySetAttribute(index=9), onlyCheckLocalBubble=attributes.BooleanAttribute(index=10), bubbleIdAddress=attributes.BlackboardAddressAttribute(index=11, is_optional=True), miningModuleTypeListID=attributes.EveTypeListSelectAttribute(index=12), cargoFullFractionThresholdAddress=attributes.BlackboardAddressAttribute(index=13), chanceOfPreferringFillingHaulersAddress=attributes.BlackboardAddressAttribute(index=14), chanceOfPreferringMinersAddress=attributes.BlackboardAddressAttribute(index=15)))
register_action('behaviors.actions.rewards.RegisterPaymentOnExplosion', dict(rewardId=attributes.NpcRewardSelectAttribute()))
register_action('behaviors.actions.structures.SelectDockableStructure', dict(selectedStructureIdAddress=attributes.BlackboardAddressAttribute(index=0), preferredStructureGroupId=attributes.InventoryGroupAttribute(index=1, is_optional=True, field_kwargs={'categories': {inv_const.categoryStructure}})))
register_action('behaviors.actions.tale.UpdateTaleContextForPersistedObject')
register_action('behaviors.actions.tanking.ActiveTank', short_description='Manage active shield and/or armor tanking', detailed_description='Activates active tanking. First checks for supported tanking effects. Supports an armor and shield effect at the same time. The can only start cycling when the task is run. The tanking stops once the the entity is at full health. The task is designed to fail by default. No effect if type has no supported effects. Supported effects are: EntityArmorRepairingLarge, EntityArmorRepairingMedium, EntityArmorRepairingSmall, NpcBehaviorArmorRepairer, EntityShieldBoostingLarge, EntityShieldBoostingMedium, EntityShieldBoostingSmall, NpcBehaviorShieldBooster')
register_action('behaviors.actions.timer.ClearTimer', dict(timerAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.timer.TimeoutAction', dict(timeoutSeconds=attributes.FloatAttribute(), timeoutMilliSecondsAddress=attributes.BlackboardAddressAttribute(is_optional=True)))
register_action('behaviors.actions.timer.FailUntilTimeoutAction', dict(timerAddress=attributes.BlackboardAddressAttribute(), triggerAddress=attributes.BlackboardAddressAttribute(), timeoutSeconds=attributes.FloatAttribute()))
register_action('behaviors.actions.timer.SucceedAfterTimeoutAction', dict(timeoutSeconds=attributes.FloatAttribute(), timeoutMilliSecondsAddress=attributes.BlackboardAddressAttribute(is_optional=True)))
register_action('behaviors.actions.timer.ClearValueAndResetAfterTimeout', dict(timeoutSeconds=attributes.FloatAttribute(), targetAddress=attributes.BlackboardAddressAttribute()))
register_action('behaviors.actions.timer.BlockWhileTimeout', dict(timerAddress=attributes.BlackboardAddressAttribute(), timeoutSeconds=attributes.FloatAttribute(), maxRandomTimeoutSeconds=attributes.FloatAttribute(is_optional=True)), short_description='This action will run suspended while it waits for its cooldown timer to complete', detailed_description='This action timer will block the tree from continuing its traversal until after the timer is completed. Timeout seconds is required, but if an integer is entered into the optional attribute max random timeout seconds, then a value between the two timeouts will be chosen at random.')
