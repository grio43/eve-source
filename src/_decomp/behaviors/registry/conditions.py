#Embedded file name: C:\BuildAgent\work\ba3dced9a47cf95a\eve\release\V22.02\packages\behaviors\registry\conditions.py
from behaviors.registry.registrator import register_condition
from fsd import attributes
register_condition('behaviors.conditions.awareness.AreClusterTargetsUsable', dict(clusterTargetSetAddress=attributes.BlackboardAddressAttribute(index=0), guardObjectIdAddress=attributes.BlackboardAddressAttribute(index=1)))
register_condition('behaviors.conditions.ballparks.IsCoordinateInSameBubbleCondition', dict(coordinateAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsCoordinateWithinDistance', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), maxDistance=attributes.FloatAttribute()))
register_condition('behaviors.conditions.ballparks.IsCoordinateWithinDistanceByAddress', dict(coordinateAddress=attributes.BlackboardAddressAttribute(), maxDistanceAddress=attributes.BlackboardAddressAttribute(), fudgeDistanceAddress=attributes.BlackboardAddressAttribute(is_optional=True)))
register_condition('behaviors.conditions.ballparks.IsBallPresentInMyBubbleCondition', dict(ballIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallPresentInBubbleByAddress', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), bubbleIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallWithInDistanceCondition', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), maxDistance=attributes.FloatAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallWithinDistanceOfBallCondition', dict(ballIdAddress=attributes.BlackboardAddressAttribute(), sourceBallIdAddress=attributes.BlackboardAddressAttribute(), maxDistance=attributes.FloatAttribute()))
register_condition('behaviors.conditions.ballparks.IsOrbitingTargetCondition', dict(targetAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallCloakedCondition', dict(ballIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallInWarpCondition', dict(ballIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsLocationWithinWarpDistance', dict(coordinateAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.IsBallWithinWarpDistance', dict(ballIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.HasValidBallTarget', dict(ballIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.ballparks.AreItemsWithInDistanceCondition', dict(itemIdAddress=attributes.BlackboardAddressAttribute(), otherItemIdAddress=attributes.BlackboardAddressAttribute(is_optional=True), maxDistanceAddress=attributes.BlackboardAddressAttribute(), maxDistanceMultiplier=attributes.FloatAttribute(is_optional=True)))
register_condition('behaviors.conditions.ballparks.IsPathToCoordinatesClearOfBubbles', dict(coordinateAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.battlefield.IsFleetTypeEqualTo', dict(fleetType=attributes.FleetTypeAttribute(index=0), fleetTypeToCounterAddress=attributes.BlackboardAddressAttribute(index=1)))
register_condition('behaviors.conditions.battlefield.IsAnyFleetMemberMemberAggressed', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0)))
register_condition('behaviors.conditions.battlefield.IsPlayerFleetRelativeStrengthToHigh', dict(playerItemIdsAddress=attributes.BlackboardAddressAttribute(index=0), relativeStrengthThreshold=attributes.FloatAttribute(default=1.0, index=1)))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueNone', dict(valueAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueNotNone', dict(valueAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueTrue', dict(valueAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardStringEqualToValue', attributes=dict(valueAddress=attributes.BlackboardAddressAttribute(index=0), expectedValue=attributes.StringAttribute(index=1)), short_description='Succeed if a blackboard value equals expected string', detailed_description='Compares a value from blackboard identified by valueAddress to the string in expectedValue. Condition succeeds if they are the same or fails otherwise.')
register_condition('behaviors.conditions.blackboards.IsBlackboardValueFalse', dict(valueAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.BlackboardMessagesEqualCondition', dict(firstMessageAddress=attributes.BlackboardAddressAttribute(), secondMessageAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardCollectionEmpty', dict(collectionAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.BlackboardValueUpdatedRecentlyCondition', dict(address=attributes.BlackboardAddressAttribute(), timeInSeconds=attributes.IntegerAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueInCollectionCondition', dict(valueAddress=attributes.BlackboardAddressAttribute(), collectionAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.BlackboardMessageAndMyItemIdEqualCondition', dict(messageAddress=attributes.BlackboardAddressAttribute(), isInverted=attributes.BooleanAttribute(is_optional=True)))
register_condition('behaviors.conditions.blackboards.BlackboardMessageAndMyEntityGroupIdEqualCondition', dict(messageAddress=attributes.BlackboardAddressAttribute(), isInverted=attributes.BooleanAttribute(is_optional=True)))
register_condition('behaviors.conditions.blackboards.IsBlackboardValue3dVector', dict(valueAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardIntegerEqualToValue', dict(valueAddress=attributes.BlackboardAddressAttribute(), value=attributes.IntegerAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueRatioLessThan', dict(firstValueAddress=attributes.BlackboardAddressAttribute(), secondValueAddress=attributes.BlackboardAddressAttribute(), ratioAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.BlackboardValueEqualsBlackboardValueInDictionaryCondition', dict(valueAddress=attributes.BlackboardAddressAttribute(), keyAddress=attributes.BlackboardAddressAttribute(), dictionaryAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.blackboards.IsBlackboardValueLessThenBlackboardValue', dict(valueToCheckAddress=attributes.BlackboardAddressAttribute(index=0), valueToCompareAddress=attributes.BlackboardAddressAttribute(index=1)))
register_condition('behaviors.conditions.blackboards.IsBlackboardDeleted', dict(scopeType=attributes.BlackboardScopeTypeAttribute(index=0, description='The blackboard scope type to query')), short_description='Check if the blackboard has been deleted', detailed_description="This will check if the blackboard matching the scope type and the behavior context has been deleted.  This is relevant for instance if an entity can out live the scope. For example if an NPC can survive the deletion of a dungeon it's part of.")
register_condition('behaviors.conditions.combat.HasValidTarget', dict(selectedTargetAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.combat.HasAvailableTargetCapacity')
register_condition('behaviors.conditions.combat.HasItemsFromCollectionWithinRange', dict(itemIdCollectionAddress=attributes.BlackboardAddressAttribute(), detectionRangeAddress=attributes.BlackboardAddressAttribute(), includeCloakedItems=attributes.BooleanAttribute()))
register_condition('behaviors.conditions.combatmodules.IsModuleActive', dict(moduleAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.combattargets.HasPendingTarget', dict(targetAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.combattargets.AmIWithinMyEffectiveCombatRangeOfMyTarget', dict(targetAddress=attributes.BlackboardAddressAttribute(index=0), orbitTargetAddress=attributes.BlackboardAddressAttribute(index=1), maxEffectiveCombatRangeAddress=attributes.BlackboardAddressAttribute(index=2), commanderAddress=attributes.BlackboardAddressAttribute(index=3)))
register_condition('behaviors.conditions.combattargets.IsCoordinateWithinMyEffectiveCombatRange', dict(coordinateAddress=attributes.BlackboardAddressAttribute(index=0), maxEffectiveCombatRangeAddress=attributes.BlackboardAddressAttribute(index=1)))
register_condition('behaviors.conditions.combattargets.IsTargeting', dict(targetAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.drones.CanControlDrones')
register_condition('behaviors.conditions.drones.HasDroneBandwidth', dict(droneGroupIdAddress=attributes.BlackboardAddressAttribute(index=1), maxDroneActiveCountAddress=attributes.BlackboardAddressAttribute(index=2)))
register_condition('behaviors.conditions.dungeons.DungeonIsMyDungeonSpawnAlive')
register_condition('behaviors.conditions.effects.IsEffectActive', dict(effectId=attributes.DogmaEffectIdAttribute()))
register_condition('behaviors.conditions.effects.IsEffectByAddressActive', dict(effectIDAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.effects.IsAnyEffectActive', dict(effectIds=attributes.DogmaEffectIdSetAttribute()))
register_condition('behaviors.conditions.effects.HasAnyEffectCondition', dict(effectIds=attributes.DogmaEffectIdSetAttribute()))
register_condition('behaviors.conditions.entities.HasAnyOfTypesInEntityAdditionalLoot', dict(typeIds=attributes.InventoryTypeSetAttribute()))
register_condition('behaviors.conditions.entities.HasEnoughCargoForType', dict(typeIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.entities.IsCargoAboveCapacityThreshold', dict(cargoCapacityThreshold=attributes.FloatAttribute()))
register_condition('behaviors.conditions.entities.OwnerIsNpcCondition', dict(ownerIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.entities.AmITheCommander')
register_condition('behaviors.conditions.entities.IsMyCargoFull')
register_condition('behaviors.conditions.entityspawning.HasSpawnPointsGreaterThan', dict(spawnPoolIdAddress=attributes.BlackboardAddressAttribute(index=0), minSpawnPointAmount=attributes.IntegerAttribute(index=1)))
register_condition('behaviors.conditions.group.IsMemberInEntityGroup', dict(memberIdAddress=attributes.BlackboardAddressAttribute()))
register_condition('behaviors.conditions.group.IsMemberTypeIdPartOfGroup', dict(typeId=attributes.InventoryTypeAttribute()))
register_condition('behaviors.conditions.group.IsOtherEntityGroupBlackboardValueTrue', dict(memberIdAddress=attributes.BlackboardAddressAttribute(), messageName=attributes.StringAttribute()))
register_condition('behaviors.conditions.group.IsAnyGroupMemberAggressed')
register_condition('behaviors.conditions.group.IsGroupInitialSpawningComplete')
register_condition('behaviors.conditions.randomized.RandomChanceCondition', dict(chance=attributes.FloatAttribute()))
register_condition('behaviors.conditions.randomized.CachedRandomChanceCondition', dict(chance=attributes.FloatAttribute(), randomValueAddress=attributes.BlackboardAddressAttribute(), cacheTimeInSeconds=attributes.IntegerAttribute()))
register_condition('behaviors.conditions.reinforcements.AreAnyReinforcementMembersAlive')
register_condition('behaviors.conditions.structures.IsStructureVulnerable', dict(structureIdAddress=attributes.BlackboardAddressAttribute()))
